//$ go run github.com/rhu1/fgg -fgg -eval=-1 -v examples/fgg/londongophers21/nomono/list/list.fgg

package main;

import "fmt";

/* Library: Bool, Int */

type Bool(type ) interface {
	Not(type )() Bool();
	Equal(type )(that Bool()) Bool();
	Cond(type a Any())(br Branches(a)) a
};
type Branches(type a Any()) interface {
	IfTT(type )() a;
	IfFF(type )() a
};
type TT(type ) struct {};
type FF(type ) struct {};
func (this TT(type )) Not(type )() Bool() { return FF(){} };
func (this FF(type )) Not(type )() Bool() { return TT(){} };
func (this TT(type )) Equal(type )(that Bool()) Bool() { return that };
func (this FF(type )) Equal(type )(that Bool()) Bool() { return that.Not()() };
func (this TT(type )) Cond(type a Any())(br Branches(a)) a { return br.IfTT()() };
func (this FF(type )) Cond(type a Any())(br Branches(a)) a { return br.IfFF()() };

type Int(type ) interface {
	Inc(type )() Int();
	Dec(type )() Int();
	Add(type )(x Int()) Int();
	Gt(type )(x Int()) Bool();
	IsNeg(type )() Bool();

	Equal(type )(x Int()) Bool();
	EqualZero(type )() Bool();
	EqualNonZero(type )(x Int()) Bool()
};

type Zero(type ) struct {};
func (x0 Zero(type )) Inc(type )() Int() { return Pos(){x0} };
func (x0 Zero(type )) Dec(type )() Int() { return Neg(){x0} };
func (x0 Zero(type )) Add(type )(x Int()) Int() { return x };
func (x0 Zero(type )) Gt(type )(x Int()) Bool() { return x.IsNeg()() };
func (x0 Zero(type )) IsNeg(type )() Bool() { return FF(){} };

type Pos(type ) struct { dec Int() };
func (x0 Pos(type )) Inc(type )() Int() { return Pos(){x0} };
func (x0 Pos(type )) Dec(type )() Int() { return x0.dec };
func (x0 Pos(type )) Add(type )(x Int()) Int() { return x0.dec.Add()(x.Inc()()) };
func (x0 Pos(type )) Gt(type )(x Int()) Bool() { return x0.dec.Gt()(x.Dec()()) };
func (x0 Pos(type )) IsNeg(type )() Bool() { return FF(){} };

type Neg(type ) struct { inc Int() };
func (x0 Neg(type )) Inc(type )() Int() { return x0.inc };
func (x0 Neg(type )) Dec(type )() Int() { return Neg(){x0} };
func (x0 Neg(type )) Add(type )(x Int()) Int() { return x0.inc.Add()(x.Dec()()) };
func (x0 Neg(type )) Gt(type )(x Int()) Bool() { return x0.inc.Gt()(x.Inc()()) };
func (x0 Neg(type )) IsNeg(type )() Bool() { return TT(){} };

type Ints(type ) struct {};
func (d Ints(type )) _1(type )() Int() { return Pos(){Zero(){}} };
func (d Ints(type )) _2(type )() Int() { return d._1()().Add()(d._1()()) };
func (d Ints(type )) _3(type )() Int() { return d._2()().Add()(d._1()()) };
func (d Ints(type )) _4(type )() Int() { return d._3()().Add()(d._1()()) };
func (d Ints(type )) _5(type )() Int() { return d._4()().Add()(d._1()()) };
func (d Ints(type )) _6(type )() Int() { return d._5()().Add()(d._1()()) };
func (d Ints(type )) __1(type )() Int() { return Neg(){Zero(){}} };
func (d Ints(type )) __2(type )() Int() { return d.__1()().Add()(d.__1()()) };
func (d Ints(type )) __3(type )() Int() { return d.__2()().Add()(d.__1()()) };
func (d Ints(type )) __4(type )() Int() { return d.__3()().Add()(d.__1()()) };
func (d Ints(type )) __5(type )() Int() { return d.__4()().Add()(d.__1()()) };


/* Prev. example */

type Any(type ) interface {};
type Function(type a Any(), b Any()) interface {
	Apply(type )(x a) b
};
type incr(type ) struct { n Int() };
func (this incr(type )) Apply(type )(x Int()) Int() {
	return x.Add()(this.n)
};
type pos(type ) struct {};
func (this pos(type )) Apply(type )(x Int()) Bool() {
	return x.Gt()(Zero(){})
};


/* Example code */

type Eq(type a Eq(a)) interface {
	Equal(type )(that a) Bool()
};
/*func (this int) Equal(that int) bool {
	return this == that
};
func (this bool) Equal(that bool) bool {
	return this == that
};*/
func (x0 Zero(type )) Equal(type )(x Int()) Bool() { return x.EqualZero()() };
func (x0 Zero(type )) EqualZero(type )() Bool() { return TT(){} };
func (x0 Zero(type )) EqualNonZero(type )(x Int()) Bool() { return FF(){} };
func (x0 Pos(type )) Equal(type )(x Int()) Bool() { return x0.EqualNonZero()(x) };
func (x0 Pos(type )) EqualZero(type )() Bool() { return FF(){} };
func (x0 Pos(type )) EqualNonZero(type )(x Int()) Bool() { return x.Equal()(x0.dec) };
func (x0 Neg(type )) Equal(type )(x Int()) Bool() { return x0.EqualNonZero()(x) };
func (x0 Neg(type )) EqualZero(type )() Bool() { return FF(){} };
func (x0 Neg(type )) EqualNonZero(type )(x Int()) Bool() { return x.Equal()(x0.inc) };

type List(type a Any()) interface {
	Map(type b Any())(f Function(a, b)) List(b)
};
type Nil(type a Any()) struct {};
type Cons(type a Any()) struct {
	head a;
	tail List(a)
};
func (xs Nil(type a Any())) 
			/*Map(type b Any())(f Function(a, b)) List(b) {
	return Nil(b){}*/
			Map(type c Any())(f Function(a, c)) List(c) {
	return Nil(c){}
};
func (xs Cons(type a Any())) 
			Map(type b Any())(f Function(a, b)) List(b) {
	return Cons(b){f.Apply()(xs.head), xs.tail.Map(b)(f)}
};

//type D(type a List(Any())) struct {};
type D(type a List(b), b Any()) struct {};
/*func (x0 D(type a List(b), b Any())) ok(type )(x1 a, x2 b)) Any() {
	//return D(a, b){}.ok()(Cons(b){x2, x1}, x2)  // CHECKME?
	return D(List(b), b){}.ok()(Cons(b){x2, x1}, x2)
	//return D(List(b), b){}.ok()(Cons(List(b)){x1, Nil(List(b)){}}, x2)  // Cons(List(b)) <:/ List(b)
};*/

////func (x0 D(type a List(b), b Any())) ok(type )(x1 a, x2 b)) Any() {   // FIXME extra b)) not detected
//func (x0 D(type a List(Any()))) ok(type )(x1 a) Any() {
func (x0 D(type a List(b), b Any())) ok(type )(x1 a) Any() {
	////return x0.ok()(Cons(Any()){x1, Nil(Any()){}}, Nil(b){})  // CHECKME
	//return D(List(Any())){}.ok()(Cons(Any()){x1, Nil(Any()){}})  // OK
	return D(List(Any()), Any()){}.ok()(Cons(Any()){x1, Nil(Any()){}})  // OK
};

/*
// CHECKME: why nomono even when not used?
//func (x0 D(type a List(Any()))) ko(type )(x1 a) Any() {
func (x0 D(type a List(b), b Any())) ko(type )(x1 a) Any() {
	//return D(List(List(b))){}.ko()(Cons(List(b)){x1, Nil(List(b)){}})
	return D(List(List(b)), List(b)){}.ko()(Cons(List(b)){x1, Nil(List(b)){}})  // KO
	// FIXME formatting: D(type a List(b), b Any()) ->* D(Cons(List(b))List(b))
};
//*/

/*type E(type a List(Any()))) struct {};
func (x0 E(type a List(Any()))) ok2(type )(x1 a)) Any() {
	return E(List(Any())){}.ok2()(Cons(Any()){x1, Nil(Any()){}})
};*/

// CHECKME: List(Int()) <: List(Any()) -- cf. Java

type A(type ) struct {};

func main() {
	////fmt.Printf("%#v", D(List(Int()), Int()){}.ok()(Nil(Int()){}, Ints(){}._1()()))
	////fmt.Printf("%#v", D(List(Int()), Int()){}.ko()(Nil(Int()){}, Ints(){}._1()()))
	////fmt.Printf("%#v", E(List(Any())){}.ok2()(Nil(Any()){}))
	//fmt.Printf("%#v", D(List(Any())){}.ok()(Nil(Any()){}))
	fmt.Printf("%#v", D(List(Any()), Any()){}.ok()(Nil(Any()){}))
	//fmt.Printf("%#v", D(List(Any()), Any()){}.ko()(Nil(Any()){}))
	/*
	fmt.Printf("%#v", Cons(Int()){Ints(){}._3()(), Cons(Int()){Ints(){}._6()(), Nil(Int()){}}}.  
				Map(Int())(incr(){Ints(){}.__5()()}).  
				Map(Bool())(pos(){}))
	//*/
}

/*
type Any interface {}
type List[a Any] interface { mapp() List[a] }  // Dummy version of map method
type Nil[a Any] struct {}
func (x0 Nil[a]) mapp() List[a] { return x0 }
type Cons[a Any] struct { head a; tail List[a] }
func (x0 Cons[a]) mapp() List[a] { return x0 }

type D[a List[b], b Any] struct {};
func (x0 D[a, b]) ok(x1 a) Any {
    fmt.Print(".")
    return D[List[Any], Any]{}.ok(
            Cons[Any]{x1, Nil[Any]{}})
}

// CHECKME: why nomono even when not used?
func (x0 D[a, b]) ko(x1 a) Any {
    return D[List[List[b]], List[b]]{}.ko(
            Cons[List[b]]{x1, Nil[List[b]]{}})
}

func main() {
    _ = "%#v", D[List[Any], Any]{}.ok(Nil[Any]{})
}
//*/

